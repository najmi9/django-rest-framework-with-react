{"ast":null,"code":"\"use strict\";\n/**\n * Full blown HTML parsing based on htmlparser2.\n * Pulls in a heavy set of dependencies and thus WILL bloat your bundle size.\n * You have been warned.\n **/\n\nvar React = require('react');\n\nvar xtend = require('xtend');\n\nvar visit = require('unist-util-visit');\n\nvar HtmlToReact = require('html-to-react');\n\nvar symbols = require('../symbols');\n\nvar type = 'parsedHtml';\nvar selfClosingRe = /^<(area|base|br|col|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)\\s*\\/?>$/i;\nvar startTagRe = /^<([a-z]+)\\b/i;\nvar closingTagRe = /^<\\/([a-z]+)\\s*>$/;\nvar parser = new HtmlToReact.Parser();\nvar processNodeDefinitions = new HtmlToReact.ProcessNodeDefinitions(React);\nvar defaultConfig = {\n  isValidNode: function isValidNode(node) {\n    return node.type !== 'script';\n  },\n  processingInstructions: [{\n    shouldProcessNode: function shouldProcessNode() {\n      return true;\n    },\n    processNode: processNodeDefinitions.processDefaultNode\n  }]\n};\n\nfunction parseHtml(config, tree, props) {\n  var open;\n  var currentParent;\n  visit(tree, 'html', function (node, index, parent) {\n    if (props.escapeHtml) {\n      parent.children.splice(index, 1, {\n        type: 'text',\n        position: node.position,\n        value: node.value\n      });\n      return true;\n    }\n\n    if (props.skipHtml) {\n      parent.children.splice(index, 1);\n      return true;\n    }\n\n    if (currentParent !== parent) {\n      open = [];\n      currentParent = parent;\n    }\n\n    var selfClosing = getSelfClosingTagName(node);\n\n    if (selfClosing) {\n      parent.children.splice(index, 1, {\n        type: 'virtualHtml',\n        tag: selfClosing,\n        position: node.position\n      });\n      return true;\n    }\n\n    var current = parseNode(node, config);\n\n    if (!current || current.type === type) {\n      return true;\n    }\n\n    var matching = findAndPull(open, current.tag);\n\n    if (matching) {\n      parent.children.splice(index, 0, parsedHtml(current, matching, parent));\n    } else if (!current.opening) {\n      open.push(current);\n    }\n\n    return true;\n  }, true // Iterate in reverse\n  ); // Find any leftover HTML elements and blindly replace them with a parsed version\n\n  visit(tree, 'html', function (node, index, parent) {\n    var element = parser.parseWithInstructions(node.value, config.isValidNode, config.processingInstructions);\n\n    if (!element) {\n      parent.children.splice(index, 1);\n      return true;\n    }\n\n    parent.children.splice(index, 1, {\n      type: type,\n      element: element,\n      value: node.value,\n      position: node.position\n    });\n    return true;\n  });\n  return tree;\n}\n\nfunction findAndPull(open, matchingTag) {\n  var i = open.length;\n\n  while (i--) {\n    if (open[i].tag === matchingTag) {\n      return open.splice(i, 1)[0];\n    }\n  }\n\n  return false;\n}\n\nfunction parseNode(node, config) {\n  var match = node.value.trim().match(closingTagRe);\n\n  if (match) {\n    return {\n      tag: match[1],\n      opening: false,\n      node: node\n    };\n  }\n\n  var el = parser.parseWithInstructions(node.value, config.isValidNode, config.processingInstructions);\n\n  if (!el) {\n    return false;\n  }\n\n  var isMultiple = React.Children.count(el) > 1;\n  var isSelfClosing = !isMultiple && selfClosingRe.test(\"<\".concat(el.type, \">\"));\n\n  if (isMultiple || isSelfClosing) {\n    return {\n      type: type,\n      position: node.position,\n      node: el\n    };\n  }\n\n  var startTagMatch = node.value.trim().match(startTagRe);\n  var tag = startTagMatch ? startTagMatch[1] : el.type;\n  return {\n    tag: tag,\n    opening: true,\n    node: node,\n    element: el\n  };\n}\n\nfunction getSelfClosingTagName(node) {\n  var match = node.value.match(selfClosingRe);\n  return match ? match[1] : false;\n}\n\nfunction parsedHtml(fromNode, toNode, parent) {\n  var fromIndex = parent.children.indexOf(fromNode.node);\n  var toIndex = parent.children.indexOf(toNode.node);\n  var extracted = parent.children.splice(fromIndex, toIndex - fromIndex + 1);\n  var children = extracted.slice(1, -1);\n  return {\n    type: type,\n    children: children,\n    tag: fromNode.tag,\n    element: fromNode.element,\n    value: fromNode.node.value,\n    position: {\n      start: fromNode.node.position.start,\n      end: toNode.node.position.end,\n      indent: []\n    }\n  };\n}\n\nmodule.exports = function getHtmlParserPlugin(config, props) {\n  if (props && (typeof config.source !== 'undefined' || typeof config.children !== 'undefined')) {\n    throw new Error('react-markdown: `html-parser` must be called before use - see https://github.com/rexxars/react-markdown#parsing-html');\n  }\n\n  var htmlConfig = xtend(defaultConfig, config || {});\n  var plugin = parseHtml.bind(null, htmlConfig);\n  plugin.identity = symbols.HtmlParser;\n  return plugin;\n};","map":{"version":3,"sources":["/home/chemime/Desktop/Python/django/trainingapp/frontend/node_modules/react-markdown/lib/plugins/html-parser.js"],"names":["React","require","xtend","visit","HtmlToReact","symbols","type","selfClosingRe","startTagRe","closingTagRe","parser","Parser","processNodeDefinitions","ProcessNodeDefinitions","defaultConfig","isValidNode","node","processingInstructions","shouldProcessNode","processNode","processDefaultNode","parseHtml","config","tree","props","open","currentParent","index","parent","escapeHtml","children","splice","position","value","skipHtml","selfClosing","getSelfClosingTagName","tag","current","parseNode","matching","findAndPull","parsedHtml","opening","push","element","parseWithInstructions","matchingTag","i","length","match","trim","el","isMultiple","Children","count","isSelfClosing","test","concat","startTagMatch","fromNode","toNode","fromIndex","indexOf","toIndex","extracted","slice","start","end","indent","module","exports","getHtmlParserPlugin","source","Error","htmlConfig","plugin","bind","identity","HtmlParser"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/**\n * Full blown HTML parsing based on htmlparser2.\n * Pulls in a heavy set of dependencies and thus WILL bloat your bundle size.\n * You have been warned.\n **/\nvar React = require('react');\n\nvar xtend = require('xtend');\n\nvar visit = require('unist-util-visit');\n\nvar HtmlToReact = require('html-to-react');\n\nvar symbols = require('../symbols');\n\nvar type = 'parsedHtml';\nvar selfClosingRe = /^<(area|base|br|col|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)\\s*\\/?>$/i;\nvar startTagRe = /^<([a-z]+)\\b/i;\nvar closingTagRe = /^<\\/([a-z]+)\\s*>$/;\nvar parser = new HtmlToReact.Parser();\nvar processNodeDefinitions = new HtmlToReact.ProcessNodeDefinitions(React);\nvar defaultConfig = {\n  isValidNode: function isValidNode(node) {\n    return node.type !== 'script';\n  },\n  processingInstructions: [{\n    shouldProcessNode: function shouldProcessNode() {\n      return true;\n    },\n    processNode: processNodeDefinitions.processDefaultNode\n  }]\n};\n\nfunction parseHtml(config, tree, props) {\n  var open;\n  var currentParent;\n  visit(tree, 'html', function (node, index, parent) {\n    if (props.escapeHtml) {\n      parent.children.splice(index, 1, {\n        type: 'text',\n        position: node.position,\n        value: node.value\n      });\n      return true;\n    }\n\n    if (props.skipHtml) {\n      parent.children.splice(index, 1);\n      return true;\n    }\n\n    if (currentParent !== parent) {\n      open = [];\n      currentParent = parent;\n    }\n\n    var selfClosing = getSelfClosingTagName(node);\n\n    if (selfClosing) {\n      parent.children.splice(index, 1, {\n        type: 'virtualHtml',\n        tag: selfClosing,\n        position: node.position\n      });\n      return true;\n    }\n\n    var current = parseNode(node, config);\n\n    if (!current || current.type === type) {\n      return true;\n    }\n\n    var matching = findAndPull(open, current.tag);\n\n    if (matching) {\n      parent.children.splice(index, 0, parsedHtml(current, matching, parent));\n    } else if (!current.opening) {\n      open.push(current);\n    }\n\n    return true;\n  }, true // Iterate in reverse\n  ); // Find any leftover HTML elements and blindly replace them with a parsed version\n\n  visit(tree, 'html', function (node, index, parent) {\n    var element = parser.parseWithInstructions(node.value, config.isValidNode, config.processingInstructions);\n\n    if (!element) {\n      parent.children.splice(index, 1);\n      return true;\n    }\n\n    parent.children.splice(index, 1, {\n      type: type,\n      element: element,\n      value: node.value,\n      position: node.position\n    });\n    return true;\n  });\n  return tree;\n}\n\nfunction findAndPull(open, matchingTag) {\n  var i = open.length;\n\n  while (i--) {\n    if (open[i].tag === matchingTag) {\n      return open.splice(i, 1)[0];\n    }\n  }\n\n  return false;\n}\n\nfunction parseNode(node, config) {\n  var match = node.value.trim().match(closingTagRe);\n\n  if (match) {\n    return {\n      tag: match[1],\n      opening: false,\n      node: node\n    };\n  }\n\n  var el = parser.parseWithInstructions(node.value, config.isValidNode, config.processingInstructions);\n\n  if (!el) {\n    return false;\n  }\n\n  var isMultiple = React.Children.count(el) > 1;\n  var isSelfClosing = !isMultiple && selfClosingRe.test(\"<\".concat(el.type, \">\"));\n\n  if (isMultiple || isSelfClosing) {\n    return {\n      type: type,\n      position: node.position,\n      node: el\n    };\n  }\n\n  var startTagMatch = node.value.trim().match(startTagRe);\n  var tag = startTagMatch ? startTagMatch[1] : el.type;\n  return {\n    tag: tag,\n    opening: true,\n    node: node,\n    element: el\n  };\n}\n\nfunction getSelfClosingTagName(node) {\n  var match = node.value.match(selfClosingRe);\n  return match ? match[1] : false;\n}\n\nfunction parsedHtml(fromNode, toNode, parent) {\n  var fromIndex = parent.children.indexOf(fromNode.node);\n  var toIndex = parent.children.indexOf(toNode.node);\n  var extracted = parent.children.splice(fromIndex, toIndex - fromIndex + 1);\n  var children = extracted.slice(1, -1);\n  return {\n    type: type,\n    children: children,\n    tag: fromNode.tag,\n    element: fromNode.element,\n    value: fromNode.node.value,\n    position: {\n      start: fromNode.node.position.start,\n      end: toNode.node.position.end,\n      indent: []\n    }\n  };\n}\n\nmodule.exports = function getHtmlParserPlugin(config, props) {\n  if (props && (typeof config.source !== 'undefined' || typeof config.children !== 'undefined')) {\n    throw new Error('react-markdown: `html-parser` must be called before use - see https://github.com/rexxars/react-markdown#parsing-html');\n  }\n\n  var htmlConfig = xtend(defaultConfig, config || {});\n  var plugin = parseHtml.bind(null, htmlConfig);\n  plugin.identity = symbols.HtmlParser;\n  return plugin;\n};"]},"metadata":{},"sourceType":"script"}