{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.uniqueSort = exports.compareDocumentPosition = exports.removeSubsets = void 0;\n\nvar tagtypes_1 = require(\"./tagtypes\");\n/**\n * Given an array of nodes, remove any member that is contained by another.\n *\n * @param nodes Nodes to filter.\n */\n\n\nfunction removeSubsets(nodes) {\n  var idx = nodes.length; // Check if each node (or one of its ancestors) is already contained in the\n  // array.\n\n  while (--idx >= 0) {\n    var node = nodes[idx]; // Remove the node if it is not unique.\n    // We are going through the array from the end, so we only\n    // have to check nodes that preceed the node under consideration in the array.\n\n    if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {\n      nodes.splice(idx, 1);\n      continue;\n    }\n\n    for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\n      if (nodes.indexOf(ancestor) > -1) {\n        nodes.splice(idx, 1);\n        break;\n      }\n    }\n  }\n\n  return nodes;\n}\n\nexports.removeSubsets = removeSubsets;\n/***\n * Compare the position of one node against another node in any other document.\n * The return value is a bitmask with the following values:\n *\n * document order:\n * > There is an ordering, document order, defined on all the nodes in the\n * > document corresponding to the order in which the first character of the\n * > XML representation of each node occurs in the XML representation of the\n * > document after expansion of general entities. Thus, the document element\n * > node will be the first node. Element nodes occur before their children.\n * > Thus, document order orders element nodes in order of the occurrence of\n * > their start-tag in the XML (after expansion of entities). The attribute\n * > nodes of an element occur after the element and before its children. The\n * > relative order of attribute nodes is implementation-dependent./\n *\n * Source:\n * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n * @param nodaA The first node to use in the comparison\n * @param nodeB The second node to use in the comparison\n *\n * @return A bitmask describing the input nodes' relative position.\n *\n *        See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n *        a description of these values.\n */\n\nfunction compareDocumentPosition(nodeA, nodeB) {\n  var aParents = [];\n  var bParents = [];\n\n  if (nodeA === nodeB) {\n    return 0;\n  }\n\n  var current = tagtypes_1.hasChildren(nodeA) ? nodeA : nodeA.parent;\n\n  while (current) {\n    aParents.unshift(current);\n    current = current.parent;\n  }\n\n  current = tagtypes_1.hasChildren(nodeB) ? nodeB : nodeB.parent;\n\n  while (current) {\n    bParents.unshift(current);\n    current = current.parent;\n  }\n\n  var idx = 0;\n\n  while (aParents[idx] === bParents[idx]) {\n    idx++;\n  }\n\n  if (idx === 0) {\n    return 1\n    /* DISCONNECTED */\n    ;\n  }\n\n  var sharedParent = aParents[idx - 1];\n  var siblings = sharedParent.children;\n  var aSibling = aParents[idx];\n  var bSibling = bParents[idx];\n\n  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\n    if (sharedParent === nodeB) {\n      return 4\n      /* FOLLOWING */\n      | 16\n      /* CONTAINED_BY */\n      ;\n    }\n\n    return 4\n    /* FOLLOWING */\n    ;\n  } else {\n    if (sharedParent === nodeA) {\n      return 2\n      /* PRECEDING */\n      | 8\n      /* CONTAINS */\n      ;\n    }\n\n    return 2\n    /* PRECEDING */\n    ;\n  }\n}\n\nexports.compareDocumentPosition = compareDocumentPosition;\n/***\n * Sort an array of nodes based on their relative position in the document and\n * remove any duplicate nodes. If the array contains nodes that do not belong\n * to the same document, sort order is unspecified.\n *\n * @param nodes Array of DOM nodes\n * @returns collection of unique nodes, sorted in document order\n */\n\nfunction uniqueSort(nodes) {\n  nodes = nodes.filter(function (node, i, arr) {\n    return !arr.includes(node, i + 1);\n  });\n  nodes.sort(function (a, b) {\n    var relative = compareDocumentPosition(a, b);\n\n    if (relative & 2\n    /* PRECEDING */\n    ) {\n        return -1;\n      } else if (relative & 4\n    /* FOLLOWING */\n    ) {\n        return 1;\n      }\n\n    return 0;\n  });\n  return nodes;\n}\n\nexports.uniqueSort = uniqueSort;","map":{"version":3,"sources":["/home/chemime/Desktop/Python/django/trainingapp/frontend/node_modules/htmlparser2/node_modules/domutils/lib/helpers.js"],"names":["Object","defineProperty","exports","value","uniqueSort","compareDocumentPosition","removeSubsets","tagtypes_1","require","nodes","idx","length","node","lastIndexOf","splice","ancestor","parent","indexOf","nodeA","nodeB","aParents","bParents","current","hasChildren","unshift","sharedParent","siblings","children","aSibling","bSibling","filter","i","arr","includes","sort","a","b","relative"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.uniqueSort = exports.compareDocumentPosition = exports.removeSubsets = void 0;\nvar tagtypes_1 = require(\"./tagtypes\");\n/**\n * Given an array of nodes, remove any member that is contained by another.\n *\n * @param nodes Nodes to filter.\n */\nfunction removeSubsets(nodes) {\n    var idx = nodes.length;\n    // Check if each node (or one of its ancestors) is already contained in the\n    // array.\n    while (--idx >= 0) {\n        var node = nodes[idx];\n        // Remove the node if it is not unique.\n        // We are going through the array from the end, so we only\n        // have to check nodes that preceed the node under consideration in the array.\n        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {\n            nodes.splice(idx, 1);\n            continue;\n        }\n        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\n            if (nodes.indexOf(ancestor) > -1) {\n                nodes.splice(idx, 1);\n                break;\n            }\n        }\n    }\n    return nodes;\n}\nexports.removeSubsets = removeSubsets;\n/***\n * Compare the position of one node against another node in any other document.\n * The return value is a bitmask with the following values:\n *\n * document order:\n * > There is an ordering, document order, defined on all the nodes in the\n * > document corresponding to the order in which the first character of the\n * > XML representation of each node occurs in the XML representation of the\n * > document after expansion of general entities. Thus, the document element\n * > node will be the first node. Element nodes occur before their children.\n * > Thus, document order orders element nodes in order of the occurrence of\n * > their start-tag in the XML (after expansion of entities). The attribute\n * > nodes of an element occur after the element and before its children. The\n * > relative order of attribute nodes is implementation-dependent./\n *\n * Source:\n * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n * @param nodaA The first node to use in the comparison\n * @param nodeB The second node to use in the comparison\n *\n * @return A bitmask describing the input nodes' relative position.\n *\n *        See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n *        a description of these values.\n */\nfunction compareDocumentPosition(nodeA, nodeB) {\n    var aParents = [];\n    var bParents = [];\n    if (nodeA === nodeB) {\n        return 0;\n    }\n    var current = tagtypes_1.hasChildren(nodeA) ? nodeA : nodeA.parent;\n    while (current) {\n        aParents.unshift(current);\n        current = current.parent;\n    }\n    current = tagtypes_1.hasChildren(nodeB) ? nodeB : nodeB.parent;\n    while (current) {\n        bParents.unshift(current);\n        current = current.parent;\n    }\n    var idx = 0;\n    while (aParents[idx] === bParents[idx]) {\n        idx++;\n    }\n    if (idx === 0) {\n        return 1 /* DISCONNECTED */;\n    }\n    var sharedParent = aParents[idx - 1];\n    var siblings = sharedParent.children;\n    var aSibling = aParents[idx];\n    var bSibling = bParents[idx];\n    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\n        if (sharedParent === nodeB) {\n            return 4 /* FOLLOWING */ | 16 /* CONTAINED_BY */;\n        }\n        return 4 /* FOLLOWING */;\n    }\n    else {\n        if (sharedParent === nodeA) {\n            return 2 /* PRECEDING */ | 8 /* CONTAINS */;\n        }\n        return 2 /* PRECEDING */;\n    }\n}\nexports.compareDocumentPosition = compareDocumentPosition;\n/***\n * Sort an array of nodes based on their relative position in the document and\n * remove any duplicate nodes. If the array contains nodes that do not belong\n * to the same document, sort order is unspecified.\n *\n * @param nodes Array of DOM nodes\n * @returns collection of unique nodes, sorted in document order\n */\nfunction uniqueSort(nodes) {\n    nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });\n    nodes.sort(function (a, b) {\n        var relative = compareDocumentPosition(a, b);\n        if (relative & 2 /* PRECEDING */) {\n            return -1;\n        }\n        else if (relative & 4 /* FOLLOWING */) {\n            return 1;\n        }\n        return 0;\n    });\n    return nodes;\n}\nexports.uniqueSort = uniqueSort;\n"]},"metadata":{},"sourceType":"script"}